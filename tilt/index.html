<script>
(function(){
  const $ = s=>document.querySelector(s);
  const rnd = (a,b)=>Math.floor(Math.random()*(b-a+1))+a;
  const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));

  // ---- Game order & state (unchanged order you wanted) ----
  const ORDER = [2,3,1,10,5,11,4,6,7,8,9,12];
  const POS_OF_11 = ORDER.indexOf(11);

  const KEY = 'henProgress:v2.1';
  let currentPos = 0, highestPos = 0, consecCorrect = 0, sublevel = 1;
  let soundOn = true;

  // ---- Sizes / growth (cap so chick never bigger than hens) ----
  const CHICK_HALF = 60;     // chick approx visual half-height
  const HEN_HALF   = 70;     // hen approx half-height
  const startScale = 1;
  const MAX_SCALE  = 1.18;   // 130*1.18 ≈ 153px < hen width 160px
  const MIN_SCALE  = 0.5;
  let scale = startScale, hasBeenAboveBaseline = false;

  // ---- Motion state ----
  let tiltX = 0, tiltY = 0;   // -1..1 from sensors
  let keyX = 0, keyY = 0;     // keyboard fallback
  let dragging = false, dragX = 0, dragY = 0; // drag fallback
  let seek = null;            // {x,y,target} when tapping a hen

  // ---- Round state ----
  let round = { q:null, chick:null, hens:[], picking:false };

  // ---- UI refs ----
  const field = $('#field');
  const toast = $('#toast'), sizeBar = $('#sizeBar');
  const tblNow = $('#tblNow'), tblHint = $('#tblHint');
  const ringNum = $('#ringNum'), ringProg = $('#ringProg');
  const unlockMsg = $('#unlockMsg');
  const tiltGate = $('#tiltGate'), enableTiltBtn = $('#enableTilt');

  // ---- Helpers ----
  function groundHeight(){
    const g = field.querySelector('.ground');
    const hpx = parseFloat(getComputedStyle(g).height) || (field.clientHeight * 0.14);
    return Math.max(100, hpx);
  }
  function toastMsg(s,ms=1200){ toast.textContent=s; toast.classList.add('show'); setTimeout(()=>toast.classList.remove('show'), ms); }

  // ---- Storage ----
  function save(){ try{ localStorage.setItem(KEY, JSON.stringify({currentPos, highestPos, consecCorrect, sublevel, scale})); }catch(e){} }
  function load(){ try{
    const raw = localStorage.getItem(KEY);
    if(!raw) return;
    const d = JSON.parse(raw);
    currentPos = Math.max(0, Math.min(ORDER.length-1, d.currentPos ?? currentPos));
    highestPos = Math.max(0, Math.min(ORDER.length-1, d.highestPos ?? highestPos));
    consecCorrect = d.consecCorrect ?? 0;
    sublevel = d.sublevel ?? 1;
    scale = Math.min(MAX_SCALE, d.scale ?? startScale);
  }catch(e){} }

  // ---- Sound ----
  const audioCtx = typeof AudioContext!=='undefined' ? new AudioContext() : null;
  function beep(freq=700, dur=.07, type='triangle', vol=.11){
    if(!audioCtx || !soundOn) return;
    const o=audioCtx.createOscillator(), g=audioCtx.createGain();
    o.type=type; o.frequency.value=freq; g.gain.value=vol;
    o.connect(g).connect(audioCtx.destination); o.start();
    setTimeout(()=>{ g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime+dur); }, 0);
    o.stop(audioCtx.currentTime+dur+.01);
  }
  function chirp(){ beep(820,.07,'triangle',.12); setTimeout(()=>beep(980,.07,'triangle',.10), 60); }
  function squawk(){ beep(320,.09,'sawtooth',.15); }

  // ---- Sprites ----
  function svgChick(){
    const el=document.createElement('div'); el.className='sprite chick'; el.style.setProperty('--scale', scale);
    el.innerHTML=`<svg width="130" height="120" viewBox="0 0 130 120" aria-hidden="true">
      <defs><radialGradient id="gY" cx="40%" cy="35%" r="70%"><stop offset="0%" stop-color="#fff2a8"/><stop offset="100%" stop-color="#ffd84d"/></radialGradient></defs>
      <path d="M40 18 C50 8,65 8,72 18 C62 16,50 18,40 18" fill="#ff6b6b"/>
      <ellipse cx="60" cy="60" rx="45" ry="38" fill="url(#gY)" stroke="#00000024"/>
      <ellipse cx="48" cy="62" rx="16" ry="12" fill="#ffe88a" stroke="#00000014"/>
      <circle cx="70" cy="48" r="5" fill="#1b1b1b"/>
      <polygon points="86,58 106,64 86,70" fill="#e67e22"/>
      <line x1="48" y1="92" x2="48" y2="106" stroke="#d47d00" stroke-width="4" stroke-linecap="round"/>
      <line x1="64" y1="92" x2="64" y2="106" stroke="#d47d00" stroke-width="4" stroke-linecap="round"/>
    </svg>`;
    return el;
  }
  function svgHen(){
    const el=document.createElement('div'); el.className='sprite hen';
    el.innerHTML=`<svg width="160" height="140" viewBox="0 0 160 140" aria-hidden="true">
      <defs><radialGradient id="gH" cx="45%" cy="35%" r="70%"><stop offset="0%" stop-color="#fff"/><stop offset="100%" stop-color="#e3e3e3"/></radialGradient></defs>
      <path d="M30 24 C44 6,72 6,86 24 C72 20,52 22,30 24" fill="#ff6b6b"/>
      <ellipse cx="70" cy="70" rx="54" ry="42" fill="url(#gH)" stroke="#00000024"/>
      <circle cx="88" cy="56" r="6" fill="#1b1b1b"/>
      <polygon points="100,66 122,72 100,78" fill="#e67e22"/>
      <line x1="60" y1="108" x2="60" y2="124" stroke="#a06c00" stroke-width="5" stroke-linecap="round"/>
      <line x1="78" y1="108" x2="78" y2="124" stroke="#a06c00" stroke-width="5" stroke-linecap="round"/>
    </svg>
    <div class="label">?</div>`;
    return el;
  }

  // ---- HUD ----
  function updateSizeBar(){
    const ratio = (scale - MIN_SCALE) / (MAX_SCALE - MIN_SCALE);
    sizeBar.style.width = Math.max(0, Math.min(1, ratio))*100 + '%';
  }
  function updateRing(){
    ringNum.textContent = consecCorrect;
    const max = 5, C = 2 * Math.PI * 17;
    const ratio = Math.max(0, Math.min(1, consecCorrect / max));
    const dash = (C * ratio).toFixed(1);
    ringProg.setAttribute('stroke-dasharray', `${dash} ${Math.max(0,C-dash).toFixed(1)}`);
  }
  function updateTableHud(){
    const nowTbl = ORDER[currentPos];
    const nextTbl = ORDER[currentPos+1] ?? ORDER[currentPos];
    tblNow.textContent = nowTbl;
    tblHint.textContent = currentPos < ORDER.length-1 ? `(next: ${nextTbl}× after 5 hugs)` : '(all tables done)';
  }

  // ---- Questions ----
  function isAfter11(){ return currentPos > POS_OF_11; }
  function currentNumOptions(){ return isAfter11() ? Math.max(1, Math.min(4, sublevel)) : 4; }
  function pickTableForQuestion(){
    const biasWeight = 0.6;
    if(Math.random() < biasWeight) return ORDER[currentPos];
    const unlocked = ORDER.slice(0, highestPos+1);
    return unlocked[rnd(0, unlocked.length-1)];
  }
  function genQ(){
    const a = pickTableForQuestion();
    const b = rnd(1,12);
    const ans = a*b;
    const need = currentNumOptions() - 1;
    const wrongs = new Set();
    while(wrongs.size < need){
      const delta = rnd(-10,10);
      const g = Math.max(1, Math.min(144, ans+delta));
      if(g!==ans) wrongs.add(g);
    }
    const opts = [ans, ...Array.from(wrongs)];
    for(let i=opts.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [opts[i],opts[j]]=[opts[j],opts[i]]; }
    return {a,b,ans,options:opts};
  }

  // ---- Placement (four sides; bottom stays inside) ----
  function sidesFor(n){
    const all = ['top','right','bottom','left'];
    if(n>=4) return all;
    const chosen = new Set();
    while(chosen.size < n){ chosen.add(all[rnd(0,all.length-1)]); }
    return Array.from(chosen);
  }
  function posForSide(side,w,h){
    const edge = 14, gh = groundHeight();
    if(side==='top')    return {x:w/2, y: edge + HEN_HALF};
    if(side==='bottom') return {x:w/2, y: h - gh - HEN_HALF - edge};
    if(side==='left')   return {x: edge + HEN_HALF,  y:h/2};
    if(side==='right')  return {x: w - HEN_HALF - edge, y:h/2};
    return {x:w/2,y:h/2};
  }

  // ---- Round control ----
  function clearSprites(){ field.querySelectorAll('.sprite,.fx,.qtag').forEach(n=>n.remove()); }
  let qTag=null;
  function placeQTag(x,y,text){
    if(!qTag){ qTag=document.createElement('div'); qTag.className='qtag'; field.appendChild(qTag); }
    qTag.textContent = text;
    qTag.style.left = x+'px'; qTag.style.top = y+'px';
  }
  function nextRound(){
    clearSprites(); if(qTag){ qTag.remove(); qTag=null; }
    round.q = genQ();
    const w = field.clientWidth, h = field.clientHeight;

    // Hens
    const n = currentNumOptions();
    const sides = sidesFor(n);
    const choices = round.q.options.slice(0,n);
    round.hens = [];
    for(let i=0;i<n;i++){
      const side = sides[i];
      const el = svgHen(); field.appendChild(el);
      const p = posForSide(side,w,h);
      el.style.left = p.x+'px'; el.style.top = p.y+'px';
      el.querySelector('.label').textContent = choices[i];
      const hObj = {el, val:choices[i], correct: choices[i]===round.q.ans, side};
      round.hens.push(hObj);

      // NEW: tap/click to auto-seek to this hen
      el.addEventListener('pointerdown', (ev)=>{
        ev.preventDefault();
        if(round.picking) return;
        seek = {x:p.x, y:p.y, target:hObj};
        el.style.filter = 'brightness(1.05) drop-shadow(0 3px 6px rgba(0,0,0,.15))';
        setTimeout(()=>{ el.style.filter=''; }, 180);
      });
    }

    // Chick (start safely above ground)
    round.chick = svgChick(); field.appendChild(round.chick);
    const cx = w/2, cy = Math.min(h/2, h - groundHeight() - (CHICK_HALF*scale) - 40);
    round.chick.style.left = cx+'px'; round.chick.style.top = cy+'px';
    placeQTag(cx, cy - 70*scale, `${round.q.a} × ${round.q.b}`);
    round.picking = false;
  }

  // ---- Handle pick ----
  function onPick(target){
    if(round.picking) return;
    round.picking = true;
    const x=parseFloat(target.el.style.left), y=parseFloat(target.el.style.top);
    round.chick.style.left = x+'px'; round.chick.style.top = y+'px';
    placeQTag(x, y - 70*scale, `${round.q.a} × ${round.q.b}`);

    if(target.correct){
      chirp(); round.chick.classList.add('hug'); target.el.classList.add('hug');
      consecCorrect++; updateRing();
      scale = Math.min(MAX_SCALE, scale * 1.10);
      hasBeenAboveBaseline = hasBeenAboveBaseline || scale > startScale + 1e-6;
      round.chick.style.setProperty('--scale', scale);
      updateSizeBar();

      if(consecCorrect>=5){
        consecCorrect = 0; updateRing();
        if(currentPos > POS_OF_11 && sublevel < 4){
          sublevel++;
          toastMsg(`Sublevel ${sublevel} unlocked (${sublevel} hen${sublevel>1?'s':''})`, 1500);
        }else if(currentPos < ORDER.length-1){
          currentPos++; highestPos = Math.max(highestPos, currentPos); sublevel = (currentPos > POS_OF_11) ? 1 : 1;
          const unlocked = ORDER[currentPos];
          unlockMsg.textContent = `Unlocked ${unlocked}×! Practising it now.`; setTimeout(()=> unlockMsg.textContent = '', 2500);
          toastMsg(`Unlocked ${unlocked}×!`, 1200);
        }
        updateTableHud(); save();
      }
      setTimeout(()=>{ seek=null; nextRound(); }, 650);
    }else{
      squawk(); target.el.classList.add('shake');
      consecCorrect = 0; updateRing();
      scale = Math.max(MIN_SCALE, scale * 0.88);
      round.chick.style.setProperty('--scale', scale);
      updateSizeBar();

      if(hasBeenAboveBaseline && Math.abs(scale - startScale) <= 0.01){
        const before = ORDER[currentPos];
        currentPos = Math.max(0, currentPos - 2);
        highestPos = Math.max(highestPos, currentPos);
        sublevel = 1; consecCorrect = 0; updateRing();
        scale = startScale; hasBeenAboveBaseline = false; updateSizeBar();
        updateTableHud(); save();
        toastMsg(`Level drop: ${before}× → ${ORDER[currentPos]}×`, 1600);
      }
      setTimeout(()=>{ seek=null; nextRound(); }, 600);
    }
  }

  // ---- Movement loop (tilt + fallbacks + seek) ----
  function loop(){
    const w = field.clientWidth, h = field.clientHeight;
    const c = round?.chick; if(!c) { requestAnimationFrame(loop); return; }

    // Blend inputs (more sensitive tilt)
    let NX = Math.max(-1, Math.min(1, tiltX + keyX + dragX));
    let NY = Math.max(-1, Math.min(1, tiltY + keyY + dragY));

    // Auto-seek overrides direction
    if(seek){
      const x = parseFloat(c.style.left), y = parseFloat(c.style.top);
      const dx = seek.x - x, dy = seek.y - y;
      const mag = Math.hypot(dx,dy) || 1;
      NX = Math.max(-1, Math.min(1, dx/mag));
      NY = Math.max(-1, Math.min(1, dy/mag));
      if(mag < 64){ onPick(seek.target); requestAnimationFrame(loop); return; }
    }

    // Movement (a touch faster)
    const SPEED = 560/60;
    let x = parseFloat(c.style.left) + NX * SPEED;
    let y = parseFloat(c.style.top)  + NY * SPEED;

    // Dynamic bounds: bottom uses ground height; prevents sticking
    const half = CHICK_HALF * scale, pad = 10;
    const bottomLimit = h - groundHeight() - half - pad;
    const leftLimit   = half + pad;
    const rightLimit  = w - half - pad;
    const topLimit    = half + pad;

    if(y >= bottomLimit && NY > 0) NY = 0; // no pushing into the edge
    x = clamp(x, leftLimit, rightLimit);
    y = clamp(y, topLimit, bottomLimit);

    c.style.left = x+'px'; c.style.top = y+'px';
    const q = document.querySelector('.qtag'); if(q) { q.style.left = x+'px'; q.style.top = (y - 70*scale)+'px'; }

    // Collision (manual steer)
    for(const hObj of round.hens){
      const hx = parseFloat(hObj.el.style.left), hy = parseFloat(hObj.el.style.top);
      if(Math.hypot(hx - x, hy - y) < 64){ onPick(hObj); break; }
    }

    requestAnimationFrame(loop);
  }

  // ---- Tilt controls (higher sensitivity + smaller deadzone) ----
  function initTilt(){
    function handleOrientation(e){
      const g = e.gamma || 0;  // left(-) / right(+), -90..90
      const b = e.beta  || 0;  // tilt toward ground, -180..180
      const dead = 2;
      const nx = Math.abs(g) < dead ? 0 : Math.max(-1, Math.min(1, g / 20));
      const ny = Math.abs(b) < dead ? 0 : Math.max(-1, Math.min(1, (b - 0) / 25));
      // smoother but snappier
      tiltX = tiltX*0.7 + nx*0.3;
      tiltY = tiltY*0.7 + ny*0.3;
    }
    if(typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function'){
      tiltGate.style.display = 'flex';
      enableTiltBtn.onclick = async ()=>{
        try{
          const res = await DeviceOrientationEvent.requestPermission();
          if(res==='granted'){ window.addEventListener('deviceorientation', handleOrientation); }
        }finally{ tiltGate.style.display='none'; }
      };
    }else if(typeof DeviceOrientationEvent !== 'undefined'){
      window.addEventListener('deviceorientation', handleOrientation);
    }
  }

  // ---- Keyboard fallback ----
  document.addEventListener('keydown', e=>{
    if(e.key==='ArrowLeft')  keyX=-1;
    if(e.key==='ArrowRight') keyX= 1;
    if(e.key==='ArrowUp')    keyY=-1;
    if(e.key==='ArrowDown')  keyY= 1;
  });
  document.addEventListener('keyup', e=>{
    if(['ArrowLeft','ArrowRight'].includes(e.key)) keyX=0;
    if(['ArrowUp','ArrowDown'].includes(e.key)) keyY=0;
  });

  // ---- Drag fallback (touch/desktop) ----
  field.addEventListener('touchstart', ()=>{ dragging=true; }, {passive:true});
  field.addEventListener('touchend',   ()=>{ dragging=false; dragX=0; dragY=0; }, {passive:true});
  field.addEventListener('touchmove', e=>{
    if(!dragging) return;
    const t = e.touches[0]; const rect = field.getBoundingClientRect();
    const cx = parseFloat(round.chick.style.left), cy = parseFloat(round.chick.style.top);
    const tx = t.clientX - rect.left, ty = t.clientY - rect.top;
    const dx = tx - cx, dy = ty - cy, mag = Math.hypot(dx,dy) || 1;
    dragX = dx / mag; dragY = dy / mag;
  }, {passive:true});
  field.addEventListener('mousemove', e=>{
    if(!e.buttons){ dragX=0; dragY=0; return; }
    const rect = field.getBoundingClientRect();
    const cx = parseFloat(round.chick.style.left), cy = parseFloat(round.chick.style.top);
    const tx = e.clientX - rect.left, ty = e.clientY - rect.top;
    const dx = tx - cx, dy = ty - cy, mag = Math.hypot(dx,dy) || 1;
    dragX = dx / mag; dragY = dy / mag;
  });

  // ---- Game flow & buttons ----
  function updateUI(){ updateTableHud(); updateRing(); updateSizeBar(); }
  function hardReset(){
    currentPos = 0; highestPos = 0; consecCorrect = 0; sublevel = 1;
    scale = startScale; hasBeenAboveBaseline = false;
    updateUI(); save(); nextRound();
  }

  $('#play').onclick=()=>{
    load(); updateUI();
    document.body.classList.add('fullscreen');
    initTilt(); nextRound(); loop();
  };
  $('#reset').onclick=()=>{ hardReset(); toastMsg('Reset'); };
  $('#clear').onclick=()=>{ try{ localStorage.removeItem(KEY); }catch(e){} hardReset(); toastMsg('Progress cleared', 1000); };
  $('#mute').onclick=()=>{ soundOn=!soundOn; $('#mute').textContent = soundOn? '🔊 Sound':'🔇 Muted'; };
  $('#exitFS').onclick=()=>{ document.body.classList.remove('fullscreen'); clearSprites(); };

  // Boot (menu state)
  updateUI();
})();
</script>
